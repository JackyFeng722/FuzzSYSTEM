"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.ReactTreeNodeElement = void 0;
exports.getElementInfo = getElementInfo;

var _findDebugSource = require("./findDebugSource");

var _findFiberByHtmlElement = require("./findFiberByHtmlElement");

var _getFiberLabel = require("./getFiberLabel");

var _getAllWrappingParents = require("./getAllWrappingParents");

var _deduplicateLabels = require("../../functions/deduplicateLabels");

var _getFiberOwnBoundingBox = require("./getFiberOwnBoundingBox");

var _getAllParentsElementsAndRootComponent = require("./getAllParentsElementsAndRootComponent");

var _isStyled = require("./isStyled");

var _goUpByTheTree = require("../goUpByTheTree");

var _HtmlElementTreeNode = require("../HtmlElementTreeNode");

function getElementInfo(found) {
  // Instead of labels, return this element, parent elements leading to closest component, its component labels, all wrapping components labels.
  const labels = [];
  const fiber = (0, _findFiberByHtmlElement.findFiberByHtmlElement)(found, false);

  if (fiber) {
    const {
      component,
      componentBox,
      parentElements
    } = (0, _getAllParentsElementsAndRootComponent.getAllParentsElementsAndRootComponent)(fiber);
    const allPotentialComponentFibers = (0, _getAllWrappingParents.getAllWrappingParents)(component); // This handles a common case when the component root is basically the comopnent itself, so I want to go to usage of the component
    // TODO: whaat? why? currently I see that it adds the original styled components which is not necessary.
    // if (fiber.return && fiber.return === fiber._debugOwner) {
    //   allPotentialComponentFibers.unshift(fiber.return);
    // }

    allPotentialComponentFibers.forEach(fiber => {
      const fiberWithSource = (0, _findDebugSource.findDebugSource)(fiber);

      if (fiberWithSource) {
        const label = (0, _getFiberLabel.getFiberLabel)(fiberWithSource.fiber, fiberWithSource.source);
        labels.push(label);
      }
    });
    const thisLabel = (0, _getFiberLabel.getFiberLabel)(fiber, (0, _findDebugSource.findDebugSource)(fiber)?.source);

    if ((0, _isStyled.isStyledElement)(fiber)) {
      thisLabel.label = `${thisLabel.label} (styled)`;
    }

    return {
      thisElement: {
        box: (0, _getFiberOwnBoundingBox.getFiberOwnBoundingBox)(fiber) || found.getBoundingClientRect(),
        ...thisLabel
      },
      htmlElement: found,
      parentElements: parentElements,
      componentBox,
      componentsLabels: (0, _deduplicateLabels.deduplicateLabels)(labels)
    };
  }

  return null;
}

class ReactTreeNodeElement extends _HtmlElementTreeNode.HtmlElementTreeNode {
  getSource() {
    const fiber = (0, _findFiberByHtmlElement.findFiberByHtmlElement)(this.element, false);

    if (fiber && fiber._debugSource) {
      return {
        fileName: fiber._debugSource.fileName,
        lineNumber: fiber._debugSource.lineNumber,
        columnNumber: fiber._debugSource.columnNumber
      };
    }

    return null;
  }

  getComponent() {
    const fiber = (0, _findFiberByHtmlElement.findFiberByHtmlElement)(this.element, false);
    const componentFiber = fiber?._debugOwner;

    if (componentFiber) {
      const fiberLabel = (0, _getFiberLabel.getFiberLabel)(componentFiber, (0, _findDebugSource.findDebugSource)(componentFiber)?.source);
      return {
        label: fiberLabel.label,
        callLink: fiberLabel.link && {
          fileName: fiberLabel.link.filePath,
          lineNumber: fiberLabel.link.line,
          columnNumber: fiberLabel.link.column,
          projectPath: fiberLabel.link.projectPath
        } || undefined
      };
    }

    return null;
  }

}

exports.ReactTreeNodeElement = ReactTreeNodeElement;

function getTree(element) {
  const originalRoot = new ReactTreeNodeElement(element);
  return (0, _goUpByTheTree.goUpByTheTree)(originalRoot);
}

const reactAdapter = {
  getElementInfo,
  getTree
};
var _default = reactAdapter;
exports.default = _default;